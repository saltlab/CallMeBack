{
  "name": "route-pattern",
  "version": "0.0.6",
  "description": "Generic Sinatra/Backbone style route pattern matching",
  "main": "route-pattern.js",
  "scripts": {
    "test": "mocha"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/bjoerge/route-pattern.git"
  },
  "keywords": [
    "route",
    "pattern"
  ],
  "author": {
    "name": "Bjørge Næss"
  },
  "license": "MIT",
  "devDependencies": {
    "browserify": "~2.13.2",
    "uglify-js": "~2.2.5",
    "semver": "~1.1.4",
    "mocha": "~1.9.0"
  },
  "testling": {
    "files": [
      "test/*.js"
    ],
    "harness": "mocha",
    "browsers": {
      "ie": [
        "8",
        "9",
        "10"
      ],
      "ff": [
        "18",
        "19"
      ],
      "chrome": [
        "25",
        "canary"
      ],
      "opera": [
        "11.6",
        "12",
        "next"
      ],
      "iphone": [
        "6.0"
      ],
      "ipad": [
        "6.0"
      ],
      "safari": [
        "5.1",
        "6.0"
      ]
    }
  },
  "readme": "# route-pattern\n\n#### Generic route pattern matching\n\n# Features\n\nThe most important feature of this library is that it does pattern matching and nothing, *nothing* more.\n\nOther features are:\n\n* Environment, framework and tool agnostic. Works in both Node.js and the browser. No jQuery, Express etc. needed.\n* Match against the *path*, *search* (query string) and the *hash* part of a location\n* Define patterns for matching *only* against the parts of the location you are interested in\n* Match against a location and capture named parameters, query string, etc.\n* Well tested.\n\nIn other words, you *could* use this library to support routing in your app or framework.\n\n### Example: matching a route against a path \n\n```js\nvar pattern = RoutePattern.fromString(\"/planets/:planet\")\npattern.matches(\"/planets/earth?fruit=apple#bookmark\") // true\n```\n\n### Matching a route by query string\n\n```js\nvar pattern = RoutePattern.fromString(\"?foo=:foo&fruit=:fruit\")\npattern.matches(\"/hello/world?foo=bar&fruit=apple\") // true\npattern.matches(\"/ignore/what/is/here?fruit=apple&foo=bar\") // true\n```\n\n### Matching a route by location hash\n\nPath-like patterns can be used in the hash part of the route string too.\n\n```js\nvar pattern = RoutePattern.fromString(\"#/chapters/:chapter\")\npattern.matches(\"#/chapters/5\") // true\npattern.matches(\"/books/3432?display=full#/chapters/2\") // true\n```\n\n### Wildcard matches \n\nBy default, query string routes will match *only* when all speficied parameters are present in \nthe matched location string, and they are the *only* query parameters in the location string.\nThus, the following statement will be `false`:\n\n```js\nRoutePattern.fromString(\"?foo=:foo\").matches(\"?foo=bar&baz=qux\") // false\n```\n\nTo specify that other query parameters should be allowed, add a single wildcard to the route string:\n\n```js\nRoutePattern.fromString(\"?foo=:foo&*\").matches(\"?foo=bar&baz=qux\") // true\n```\n\nWildcards can also be used in the path to ignore whatever is in the place of the `*`\n\n```js\nvar pattern = RoutePattern.fromString(\"*/planets/:planet/*\")\npattern.matches(\"/some/root/path/planets/earth/facts/about/this/planet\") // true\n```\n\n## Getting match data\n\n```js\nvar pattern = RoutePattern.fromString(\"/hello/:planet?foo=:foo&fruit=:fruit#:section\")\npattern.match(\"/hello/earth?foo=bar&fruit=apple#chapter2\");\n// Returns:\n{\n  params: [\"bar\", \"apple\"],\n  namedParams: { planet: \"earth\", foo: \"bar\", fruit: \"apple\" }\n  pathParams: { planet: \"world\" }\n  queryParams: { foo: \"bar\", fruit: \"apple\" }\n  hashParams: { section: \"chapter2\" }\n}\n```\n\nNote: `namedParams` is a merge of `pathParams`, `queryParams` and `hashParams`.\n\n### Capturing wildcards and splats\n\nWildcards in the route string will ignore whatever is in the place of the `*`\n\n```js\nvar pattern = RoutePattern.fromString(\"*/planets/:planet/*\")\npattern.match(\"/some/root/path/planets/earth/facts/about/this/planet\") // true\n// Returns:\n{\n  params: [\"earth\"],\n  namedParams: {\n    planet: \"earth\"\n  }\n  //...\n}\n```\n\nSplat parameters is like wildcards, only that they will capture the value of the identifier that comes after the `*` \n\n```js\nvar pattern = RoutePattern.fromString(\"*before/planets/:planet/*after\")\npattern.match(\"/some/root/path/planets/earth/facts/about/this/planet\")\n// Returns:\n{\n  params: [\"some/root/path\",\"earth\",\"facts/about/this/planet\"],\n  namedParams: {\n    before: \"some/root/path\",\n    planet: \"earth\",\n    after:\"facts/about/this/planet\"\n  }\n  //...\n}\n```\n\n# Getting started\n\n## Node.js\n1. Install with npm: `npm install route-pattern`\n2. From your .js file: `var RoutePattern = require(\"route-pattern\");` \n\n## Browser\n\nThis module works in all major browsers, including IE 8-10. However, it makes use of ECMAScript 5 features, so in \norder to make it work on legacy browsers, you need to include a ECMAScript 5 shim, like the [es5-shim](https://github.com/kriskowal/es5-shim). \n\nDownload latest version:\n* [Source](https://raw.github.com/bjoerge/route-pattern/master/route-pattern-standalone-0.0.3.js)\n* [Minified](https://raw.github.com/bjoerge/route-pattern/master/route-pattern-standalone-0.0.3.min.js)\n\nWhen included with a &lt;script&gt; tag, it it will expose the `RoutePattern` class as a global variable.\n\n# API\n\n### `RoutePattern.fromString(routeString)`\nCompiles a route string and returns a RoutePattern instance.\n\n### `new RoutePattern(opts)`\nConstructor. Usually its better to use `RoutePattern.fromString(routeString)` instead of using the constructor directly.\n\n### routePattern.match(locationString)\nMatches a location string against the pattern and returns captured values (i.e.\n`params`, `namedParams`, `queryParams`, `hashParams` and `pathParams`)\n\n### routePattern.matches(locationString)\nTests whether the pattern matches a given location string\n\nExample:\n```\nRoutePattern.fromString(\"/foo/:bar\").matches(\"/foo/bar/baz\") // false\nRoutePattern.fromString(\"/foo/:bar\").matches(\"/foo/bar\") // true\n```\n\n# Future work:\n* Allow pattern matching against the full url (i.e. scheme, domain, port in addition to the currently supported parts of\nthe url). Useful where same script resides on multiple domains.\n\n# Changelog\n\n## 0.0.3\n  * Rename `RegexPattern` => `RegExpPattern`.\n  * Make all the Pattern classes' `match()` methods  return null if there are no match.\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/bjoerge/route-pattern/issues"
  },
  "homepage": "https://github.com/bjoerge/route-pattern",
  "_id": "route-pattern@0.0.6",
  "dist": {
    "shasum": "daf273da25f1e73484aefb06e5b7c680002f308d"
  },
  "_from": "route-pattern@0.0.x",
  "_resolved": "https://registry.npmjs.org/route-pattern/-/route-pattern-0.0.6.tgz"
}
