{
  "name": "await",
  "version": "0.2.1",
  "description": "Set-theoretical promises",
  "keywords": [
    "promises",
    "futures",
    "deferreds",
    "asynchronous"
  ],
  "author": {
    "name": "Greg Reimer",
    "email": "gregreimer@gmail.com",
    "url": "http://obadger.com/"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/greim/await.js.git"
  },
  "main": "./await.js",
  "readme": "# await.js\n\nawait.js is a lightweight, dependency-free promises library that makes both serial and parallel logic easy by thinking in terms of *sets*.\nYou await() a set of things, and once you have all the things, you do stuff.\nawait.js conforms to the [Promises/A+](http://promisesaplus.com/) spec.\n\n## Example\n\n```javascript\n// await this set of things\nvar getThings = await('me','feed','ready')\n\n// fulfill 'me'\n$.ajax('/api/users/me', {\n  success: function(data){ getThings.keep('me', data) },\n  error: function(err) { getThings.fail(err) }\n})\n\n// fulfill 'feed'\n$.ajax('/api/users/me/feed', {\n  success: function(data){ getThings.keep('feed', data) },\n  error: function(err) { getThings.fail(err) }\n})\n\n// fulfill 'ready'\n$(document).ready(function(){\n  getThings.keep('ready');\n})\n\n// do stuff with the things\ngetThings.then(function(got){\n  // now you got stuff\n  got.me // json object\n  got.feed // json object\n  got.ready // null; dom has loaded\n},function(err){\n  // oops, there was an error\n});\n```\n\n## Installation and use\n\nNode.js:\n\n```\n%> npm install await\n%> node\nnode> var await = require('await')\n```\n\nBrowsers:\n\n```html\n<script src=\"path/to/await.js\"></script>\n<script>\n// window.await is defined\n</script>\n```\n\nBrowsers (AMD/RequireJS):\n\n```javascript\n// window.await is NOT defined\ndefine(['await'], function(await){\n  ...\n})\n```\n\n## Old browser note\n\nYou'll need some polyfill or Modernizr goodness to use it in browsers that don't support JavaScript 1.8.5. (e.g. IE8 and lower). To that end, example-polyfills.js is included in the git repo. The polyfills file has no test coverage, and is otherwise purely optional.\n\n## How does it work?\n\nAn await promise represents a set of empty slots that need to be filled.\nA promise can be in one of three states: *unresolved*, *kept* or *failed*.\nSometimes it's useful to think in terms of it being *unresolved* or *resolved*, where *resolved* means *either kept or failed*.\n\nA promise starts out in an unresolved state.\nAs soon as each individual slot has been filled, the promise enters the kept state.\nIt doesn't matter how long it takes or in what order they're filled, or whether it's done serially or in parallel.\n\nIf something goes wrong during fulfillment, the promise enters the failed state.\nThe promise can't enter the failed state if it has already entered the kept state, or vice versa.\nOnce in either a kept or failed state, a promise will never switch to any other state.\n\n## Creating promises\n\nYou create a promise by calling the `await()` function and passing a series of strings; one for each slot you expect to be filled.\n\n```javascript\nvar prom = await('foo','bar','baz')\n```\n\n## Using promises\n\nYou use promises in two ways: the event handlers or the `then()` method.\n\n### The event handlers\n\nAn await promise has `onkeep()`, `onresolve()` and `onfail()` methods that accept callbacks.\nThese methods can be called any number of times, at any time, in any order.\n\nThese methods can be called whether the promise is resolved or unresolved.\nIf called before resolve, callbacks are stored for later execution.\nIf called after resolve, callbacks are executed immediately.\n\nAn important aspect of promises is that, whether or not a promise is resolved, your callback is always executed *after* the method returns.\nThis means that the semantics of your program don't change based on the state of a promise at any given moment.\nThat is, your code is effectively decoupled from the state of a promise, and you can always rely on it being an asynchronous operation.\n\n```javascript\npromise.onkeep(function(got){\n  got.slotA\n  got.slotB\n  //...\n})\n\npromise.onfail(function(err){\n  // handle error case\n})\n\npromise.onresolve(function(){\n  // promise is now either in\n  // a kept or failed state\n})\n```\n\nSince these methods are chainable, the above could also be written as:\n\n```javascript\npromise.onkeep(function(got){\n  //...\n}).onfail(function(err){\n  //...\n}).onresolve(function(){\n  //...\n})\n```\n\n#### Progress\n\nThere is also an `onprogress()` method which behaves differently from the above event handlers.\n`onprogress()` callbacks that are added before the promise is resolved are stored and executed any number of times (including zero) during progress events.\nProgress callbacks that are added after the promise is resolved are silently ignored.\nProgress callbacks are only called while the promise is unresolved.\nProgress callbacks are passed an object containing the current progress of each slot.\nThis object also has a `getAverage()` method that returns a number for reporting the overall progress of the promise.\nThis allows you to implement either a multi-progress bar, or a single progress bar.\nAll progress values are numbers between 0.0 and 1.0.\n\n```javascript\npromise.onprogress(function(prog){\n  progress.slotA // number between 0.0 and 1.0\n  progress.slotB // number between 0.0 and 1.0\n  // etc\n})\n```\n\n### The `then(onkeep, onfail, onprogress)` method\n\nThe `then()` method conforms to the signature and behavioral contract outlined in the [Promises/A+ spec](http://promisesaplus.com/).\nUnlike the event handlers above, which are purely consumer methods, `then()` is both consumer and provider.\nThat is, it returns a *new* promise pending on the value that will eventually be returned by its callback.\n\n```javascript\npromise.then(function(got){\n  got.slotA // etc, same as above\n  // the value returned here fulfills\n  // the promise returned by then()\n}, function(err){\n  // handle error case\n  // the value returned here fulfills\n  // the promise returned by then()\n  // same as above\n}, function(amount){\n  // there has been progress indicated\n  // by \"amount\". note that \"amount\" in\n  // this case is an average across all\n  // slots of this promise\n})\n```\n\nOthers have written good explanations on how to use \"thenables\", as they have come to be called:\n\n * http://blog.parse.com/2013/01/29/whats-so-great-about-javascript-promises/\n * https://gist.github.com/domenic/3889970\n * http://howtonode.org/promises\n * http://promisesaplus.com/\n\n#### Accumulating values over serial `then()`s\n\nIt's common to chain thenables for serial operations in order to have sane error handling and code flow.\nHowever, since thenables only keep a single value, it's difficult to accumulate values obtained this way without nesting the calls.\nThis is unfortunate since \"nested callback hell\" is something thenables were supposed to help you avoid.\n\nSince await deals in sets rather than single values, it accumulates values for you, so that you don't have to nest the calls if you don't want.\nFor example:\n\n```javascript\nfunction getUser() {\n  return await('user')...\n}\nfunction getFeed() {\n  return await('feed')...\n}\nfunction getFollowers() {\n  return await('followers')...\n}\n\ngetUser()\n.then(function(){\n  return getFeed()\n})\n.then(function(){\n  return getFollowers()\n})\n.then(function(got){\n  // do stuff with got.user\n  // do stuff with got.feed\n  // do stuff with got.followers\n})\n```\n\nIf there are name collisions, await will prefer recent values over older ones.\nTo avoid collisions, you can use await's `map()` method, which is documented in more detail later one.\nExample:\n\n```javascript\nfunction getFeed(name) { return await('feed')... }\n\ngetFeed('fez').map({'feed':'fez'})\n.then(function(){\n  return getFeed('bob').map({'feed':'bob'})\n})\n.then(function(){\n  return getFeed('ned').map({'feed':'ned'})\n})\n.then(function(got){\n  // got.fez\n  // got.bob\n  // got.ned\n})\n```\n\n## Keeping promises (or failing)\n\n### `promise.keep(name, [value])`\n\nEach slot of a promise is fulfilled using the `keep()` method.\n`keep()` must be called once for each slot.\nOnly the first call to `keep()` for a given slot has any effect on the state of the promise.\nSubsequent calls are ignored.\nIf no `value` is given, it defaults to `null`.\n\n```javascript\nvar prom = await('number','foo')\nprom.keep('number', 7)\nprom.keep('foo')\n// prom is now in a kept state\nprom.onkeep(function(got){\n  got.number // 7\n  got.foo    // null\n})\n```\n\n### `promise.fail(error)`\n\nAt any time, you can call `fail()` on a promise, passing an error object representing the failure.\nIf the promise is already in a kept or failed state, calls to `fail()` are silently ignored, and have no effect on the state of the promise.\nIf none or only some slots have been filled, `fail()` will permanently push the promise into the failed state.\n\n```javascript\nvar prom = await('foo')\nprom.fail(new Error('Fake error!'))\n// prom is now in a failed state\nprom.onfail(function(err){\n  err.message // 'Fake error!'\n})\n```\n\n### `promise.progress(name, amount)`\n\nWhile the promise is unresolved, you can call this method any number of times to notify any listeners of progress.\nCalling this method after the promise is resolved is a no-op.\n`name` is a string naming the slot that has progressed.\n`amount` is a number between 0.0 and 1.0.\nAwait does not enforce progressively higher amounts; it assumes you know what you're doing in this regard.\nHowever, it will enforce that `amount` is a number between 0.0 and 1.0.\nIf `amount` is not a number and not parseable into a number, it will be treated as zero.\n\n`progress()` also accepts an object instead of a string and a number.\nThis allows multiple progress values to be reported at once.\n\n```javascript\n// fires two events\npromise.progress('foo', .6)\npromise.progress('bar', .4)\n\n// fires one event\npromise.progress({ foo: .6, bar: .4 })\n```\n\n## Grouping promises\n\n`await()` accepts other promises in addition to strings.\nIn such cases, the newly-created promise is the *union* of all grouped promises and string arguments.\n\n```javascript\np1 = await('foo', 'bar')\np2 = await('baz')\np3 = await(p1, p2, 'qux')\n\np3.onkeep(function(got){\n  // do something with got.foo\n  // do something with got.bar\n  // do something with got.baz\n  // do something with got.qux\n})\n```\n\n`promise.map()` returns a new promise with differently-named slots, and can be used to step around name collisions.\n\n```javascript\np1 = await('model')\np2 = await('model')\np3 = await(\n  p1.map({'model':'m1'}),\n  p2.map({'model':'m2'})\n)\n\np3.onkeep(function(got){\n  // do something with got.m1\n  // do something with got.m2\n})\n```\n\n## `await.all(list)`\n\nIf you have an array of promises of arbitrary length, you can use `await.all()` to merge them into a single promise.\n\n```javascript\n// 'proms' is an array of await promises\n// that have already been created\n\nawait.all(proms)\n.onkeep(function(gots){\n\n  // 'gots' is a list with a length\n  gots.length // number\n  gots[0]\n  gots[1] (etc)\n\n  // alternatively...\n  gots.forEach(function(got){\n    got.foo\n    got.bar\n    // ...\n  })\n})\n```\n\nNote that in the above example, `gots` is an object, not a true array, despite having `length`, `0`, `1` (etc) properties.\nFor example it doesn't have mutator methods like `push()` or `splice()`.\nHowever for convenience, it does inherit several array-like accessor methods from its prototype:\n\n * forEach() - Similar to array.forEach()\n * map() - Similar to array.map()\n * some() - Similar to array.some()\n * every() - Similar to array.every()\n * reduce() - Similar to array.reduce()\n * slice() - Similar to array.slice()\n * join() - Similar to array.join()\n\n## `take(promise, [mapping])`\n\n(AKA chaining promises)\n\nPromises can be explicitly chained instead of grouped.\nHere we've declared two promises, and we want to take the outcome of one and plug it into the other:\n\n```\np1 = await('foo', 'bar', 'baz')\np2 = await('foo', 'bar', 'buz', 'qux')\n\np1      p2 \n===========\nfoo     foo\nbar     bar\nbaz     buz\n        qux\n```\n\nWhat happens is that p1 can *take* p2.\n\n```\np1.take(p2)\n```\n\np1 now takes p2, and if p2 fails, p1 fails.\nAs you can see, p2 is a different set of things than p1.\nHere is how p2 maps to p1:\n\n```\np1      p2 \n===========\nfoo <-- foo\nbar <-- bar\nbaz     buz\n        qux\n```\n\nIn other words, p1 only took the *intersection* of itself with p2.\nThus when p2 keeps, p1 remains unkept.\nYou can therefore optionally provide a mapping object:\n\n```\np1.take(p2, {'buz':'baz'})\n\np1      p2 \n===========\nfoo <-- foo\nbar <-- bar\nbaz <-- buz\n        qux\n```\n\nIf the mapping you provide conflicts with direct matches, the mapping wins:\n\n```javascript\np1.take(p2, {\n  'buz':'baz',\n  'qux':'bar'\n})\n```\n\n```\np1      p2 \n===========\nfoo <-- foo\nbar <-- qux\nbaz <-- buz\n        bar\n```\n\nYou can also take non-await thenables, such as a Q promise or a jqXHR object, provided that you name the value:\n\n```javascript\nawait('feed').take($.ajax('/api/feed'), 'feed')\n```\n\nThis is easier than doing:\n\n```javascript\nvar prom = await('feed')\n$.ajax('/api/feed', {\n  success: function(data){ prom.keep('feed', data) },\n  error: function(err){ prom.fail(err) }\n})\n```\n\n## Using `nodify()` in Node.js\n\nNode.js callbacks have an error object in the first position.\nIf the operation was successful, this argument is null, otherwise it's an instance of Error.\nEvery node callback you write therefore needs an if/else statement in order to see if this argument is not empty, which can get tedious.\nFor example, to hook up an await promise to a node callback, you'd need to do this:\n\n```javascript\nvar promise = await('logData')\n\nfs.readFile('/tmp/log', function(err, data){\n  if (err) {\n    promise.fail(err);\n  } else {\n    promise.keep('logData', data);\n  }\n});\n```\n\nAs a convenience, you can wrap the callback in `promise.nodify()`, and it will wire up the error handling automatically, shifting `err` off the signature for you:\n\n```javascript\nvar promise = await('logData')\n\nfs.readFile('/tmp/log', promise.nodify(function(data){\n  promise.keep('logData', data);\n}));\n```\n\nTo save even more typing, if you simply want to keep the promise based on the success value, you can pass a string to `nodify()` instead of a function.\nThis example below behaves equivalent to the above:\n\n```javascript\nvar promise = await('logData')\n\nfs.readFile('/tmp/log', promise.nodify('logData'));\n```\n\n### Examples\n\n#### Callback signature: (error, a, b, c)\n\n```javascript\nnodeApi.doSomething(promise.nodify('foo', 'bar'))\n// 'foo' and 'bar' are kept with values a and b, respectively.\nc is ignored\n```\n#### Callback signature: (error)\n\n```javascript\nnodeApi.doSomething(promise.nodify('foo', 'bar'))\n// 'foo' and 'bar' are both kept with value null\n```\n\n#### Callback signature (error, a, b)\n\n```javascript\nnodeApi.doSomething(promise.nodify(null, 'foo'))\n// 'foo' is kept with value b, a is ignored\n```\n\n## API overview\n\n<table summary=\"overview of api\">\n  <thead>\n    <tr>\n      <th>method</th>\n      <th>description</th>\n      <th>returns</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style=\"white-space: nowrap;font-family: monospace;font-size:90%;\">var promise =<br>await(item1, item2, ... itemN)</td>\n      <td>Returns a promise, pending the fulfillment of the given set of things. The <code>new</code> keyword is not needed. Accepts one or more args which can be strings or other promises, which allows grouping. Order of arguments is unimportant.</td>\n      <td>promise</td>\n    </tr>\n    <tr>\n      <td style=\"white-space: nowrap;font-family: monospace;font-size:90%;\">promise.run(callback[, context])</td>\n      <td>Runs <code>callback</code> immediately (synchronously), which contains whatever promise fulfillment logic you want. <code>callback</code> is passed a reference to the promise. If defined and not null, <code>context</code> will be <code>this</code> in <code>callback</code>.</td>\n      <td>itself</td>\n    </tr>\n    <tr>\n      <td style=\"white-space: nowrap;font-family: monospace;font-size:90%;\">promise.onkeep(callback[, context])</td>\n      <td>Calls <code>callback</code> when every item of the promise is fulfilled. If the promise is already fulfilled, <code>callback</code> runs immediately. <code>callback</code> is passed a map of all the things in the promise, keyed by the strings passed to <code>await()</code>. If defined and not null, <code>context</code> will be <code>this</code> in <code>callback</code>.</td>\n      <td>itself</td>\n    </tr>\n    <tr>\n      <td style=\"white-space: nowrap;font-family: monospace;font-size:90%;\">promise.onfail(callback[, context])</td>\n      <td>Calls <code>callback</code> when promise fails. If promise already failed, <code>callback</code> runs immediately. <code>callback</code> is passed the error object representing the reason for the failure, which was passed to <code>fail()</code> method triggering the failure. If defined and not null, <code>context</code> will be <code>this</code> in <code>callback</code>.</td>\n      <td>itself</td>\n    </tr>\n    <tr>\n      <td style=\"white-space: nowrap;font-family: monospace;font-size:90%;\">promise.onresolve(callback[, context])</td>\n      <td>Calls <code>callback</code> when promise either keeps or fails. If promise has already been kept or failed, <code>callback</code> runs immediately. If defined and not null, <code>context</code> will be <code>this</code> in <code>callback</code>.</td>\n      <td>itself</td>\n    </tr>\n    <tr>\n      <td style=\"white-space: nowrap;font-family: monospace;font-size:90%;\">promise.onprogress(callback[, context])</td>\n      <td>Calls <code>callback</code> whenever there is progress to report. <code>callback</code> is only called while promise is unresolved. <code>callback</code> may be called any number of times, or never called at all. If promise has already been kept or failed, <code>callback</code> is ignored and discarded. <code>callback</code> is passed an object keyed by names and valued by numbers between 0.0 and 1.0. If defined and not null, <code>context</code> will be <code>this</code> in <code>callback</code>.</td>\n      <td>itself</td>\n    </tr>\n    <tr>\n      <td style=\"white-space: nowrap;font-family: monospace;font-size:90%;\">promise.then(onkeep, onfail, onprogress)</td>\n      <td>Conforms to the signature and behavioral conventions outlined in the Promises/A+ spec.</td>\n      <td>A new await.js promise</td>\n    </tr>\n    <tr>\n      <td style=\"white-space: nowrap;font-family: monospace;font-size:90%;\">promise.catch(onfail)</td>\n      <td>Convenience method that behaves equivalent to <code>promise.then(null, onfail)</code>.</td>\n      <td>A new await.js promise</td>\n    </tr>\n    <tr>\n      <td style=\"white-space: nowrap;font-family: monospace;font-size:90%;\">promise.keep(item[, data])</td>\n      <td>Fulfills one of the things of this promise. <code>data</code> is optional and if not defined, defaults to <code>null</code>.</td>\n      <td>itself</td>\n    </tr>\n    <tr>\n      <td style=\"white-space: nowrap;font-family: monospace;font-size:90%;\">promise.fail(reason)</td>\n      <td>Fail the promise for the given <code>reason</code>. The first argument should be an error object.</td>\n      <td>itself</td>\n    </tr>\n    <tr>\n      <td style=\"white-space: nowrap;font-family: monospace;font-size:90%;\">promise.progress(name, amount)</td>\n      <td>Notify any progress listeners of progress on item <code>name</code>. <code>amount</code> is a fractional value between 0.0 and 1.0. Lower values will be converted to 0.0, higher ones converted to 1.0. </td>\n      <td>itself</td>\n    </tr>\n    <tr>\n      <td style=\"white-space: nowrap;font-family: monospace;font-size:90%;\">promise.take(otherPromise[, map])</td>\n      <td>Set up a dependency chain so that <code>promise</code> depends on <code>otherPromise</code>. <code>map</code> is optional and provides custom mapping from <code>otherPromise</code> to <code>promise</code>. The dependency is such that if <code>otherPromise</code> fails, </code>promise</code> fails.</td>\n      <td>itself</td>\n    </tr>\n    <tr>\n      <td style=\"white-space: nowrap;font-family: monospace;font-size:90%;\">promise.things()</td>\n      <td>Retrieve a list of things this promise is awaiting.</td>\n      <td>array</td>\n    </tr>\n    <tr>\n      <td style=\"white-space: nowrap;font-family: monospace;font-size:90%;\">promise.map(mapping)</td>\n      <td>Get a copy of this promise. <code>mapping</code> updates the names of the things in the new promise, which is useful for avoiding naming conflicts during grouping. The copy is automatically chained to the original.</td>\n      <td>different promise</td>\n    </tr>\n    <tr>\n      <td style=\"white-space: nowrap;font-family: monospace;font-size:90%;\">promise.nodify(item1, item2, ... itemN)</td>\n      <td>This method is intended for use with node.js's error-first callback signature. It returns a function that can be used as a callback in a node.js async call. If an error is passed to the callback, it fails the promise. Otherwise, success params are matched to each named item, in the order provided.</td>\n      <td>function</td>\n    </tr>\n    <tr>\n      <td style=\"white-space: nowrap;font-family: monospace;font-size:90%;\">promise.nodify(callback[, context])</td>\n      <td>This method is intended for use with node.js's error-first callback signature. It returns a function that can be used as a callback in a node.js async call. If an error is passed to the callback, it fails the promise. Otherwise, the callback is executed with the given context, if provided.</td>\n      <td>function</td>\n    </tr>\n  </tbody>\n</table>\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/greim/await.js/issues"
  },
  "homepage": "https://github.com/greim/await.js",
  "_id": "await@0.2.1",
  "dist": {
    "shasum": "a0048f1f70117f1a862997d3b14c855addff87c8"
  },
  "_from": "await@0.2.x",
  "_resolved": "https://registry.npmjs.org/await/-/await-0.2.1.tgz"
}
